use std::str::FromStr;
use crate::ast;
use crate::types;

grammar(id_generator: ast::IdGenerator);


pub TypeUsage: ast::TypeUsage = {
    "fn" "(" <args:Comma<TypeUsage>> ")" => ast::TypeUsage::Function(ast::FunctionTypeUsage{arguments: args, return_type: Box::new(ast::new_unit())}),
    "fn" "(" <args:Comma<TypeUsage>> ")" ":" <return_type:TypeUsage> => ast::TypeUsage::Function(ast::FunctionTypeUsage{arguments: args, return_type: Box::new(return_type)),
    <name:SpannedIdentifier> => ast::TypeUsage::Named(ast::NamedTypeUsage{name: name})
};


pub LiteralInt: i64 = {
    <literal:r"[0-9]+"> => i64::from_str(literal).unwrap()
};

pub SpannedLiteralInt: ast::LiteralInt {
    <literal_int:Spanned<LiteralInt>> => ast::LiteralInt{value: literal_int, type_: ast::TypeUsage::new_builtin("i64")}
};

pub LiteralFloat: f64 = {
    <literal:r"[0-9]+\.[0-9]+"> => f64::from_str(literal).unwrap()
};

pub SpannedLiteralInt: ast::LiteralFloat {
    <literal_float:Spanned<LiteralFloat>> => ast::LiteralFloat{value: literal_float, type_: ast::TypeUsage::new_builtin("f64")}
};

pub Identifier: String = {
    <i:r"[A-Za-z_][A-Za-z0-9_]*"> => i.to_string()
};

pub LiteralStructField: (String, Expression) {
    <field:SpannedIdentifier> ":" <expr:Expression> => (field, expr)
};

pub LiteralStruct: ast::LiteralStruct {
    <i:SpannedIdentifier> "{" <field_list:Comma<LiteralStructField>> "}" => LiteralStruct{
        name: i,
        fields: field_list.into_iter().collect(),
        type_: ast::TypeUsage::new_named(i.clone()),
    }
};

pub SpannedIdentifier: ast::Identifier {
    <i:Spanned<Identifier>> => ast::Identifier{name: i}
};

pub FunctionCall: ast::FunctionCall = {
    <source:Expression> "(" <args:Comma<Expression>> ")" => ast::FunctionCall{source: source, arguments: args, type_: ast::TypeUsage::new_unknown(&mut id_generator)}
};

pub StructGetter: ast::StructGetter = {
    <source:Expression> "." <field:SpannedIdentifier> => ast::StructGetter{source: source, attribute: field, type: ast::TypeUsage::new_unknown(&mut id_generator)}
};

pub VariableUsage: ast::VariableUsage = {
    <identifier:SpannedIdentifier> => ast::VariableUsage{name: identifier, type_: ast::TypeUsage::new_unknown(&mut id_generator)}
};

pub Subxpression: Box<ast::Subexpression> = {
    <l:Expression> "+" <r:Factor> => Box::new(ast::Subexpression::Op(ast::Operation{left: l, op: ast::Operator::Plus, right: r})),
    <l:Expression> "-" <r:Factor> => Box::new(ast::Subexpression::Op(ast::Operation{left: l, op: ast::Operator::Minus, right: r})),
    Factor,
};

pub Factor: Box<ast::Subexpression> = {
    <l:Factor> "*" <r:Term> => Box::new(ast::Subexpression::Op(ast::Operation{left: l, op: ast::Operator::Mul, right: r})),
    <l:Factor> "/" <r:Term> => Box::new(ast::Subexpression::Op(ast::Operation{left: l, op: ast::Operator::Div, right: r})),
    Term,
};

pub Term: Box<ast::Subexpression> = {
    SpannedLiteralInt => Box::new(ast::Subexpression::LiteralInt(<>)),
    SpannedLiteralFloat => Box::new(ast::Subexpression::LiteralFloat(<>)),
    SpannedLiteralStruct => Box::new(ast::Subexpression::LiteralStruct(<>)),
    FunctionCall => Box::new(ast::Subexpression::FunctionCall(<>)),
    Identifier => Box::new(ast::Subexpression::Identifier(<>)),
    "(" <e:Expression> ")" => e.subexpression,
};

pub Expression: ast::Expression = {
    <sub:Subxpression> => ast::Expression{subexpression: sub, type_: ast::TypeUsage::new_unknown(&mut id_generator)}
};

pub ReturnStatement: ast::ReturnStatement = {
    "return" <e:Expression> => ast::ReturnStatement{source: e}
};

pub LetStatement: ast::LetStatement = {
    //TODO: support destructuring with tuples, when they exist.
    //TODO: add mut, weak
    "let" <n:SpannedIdentifier> "=" <e:Expression> => ast::LetStatement{variable_name: n, type_usage: ast::TypeUsage::new_unknown(&mut id_generator), expression: e},
    "let" <n:SpannedIdentifier> ":" <t:TypeUsage> "=" <e:Expression> => ast::LetStatement{variable_name: n, type_usage: ast::TypeUsage::Named(ast::NamedTypeUsage{name: t}), expression: e},
};

pub AssignmentStatement: ast::AssignmentStatement {
    <v:VariableUsage> "=" <e:Expression> => ast::AssignmentStatement{source: ast::AssignmentTarget::Variable(v), expression: e},
    <sg:StructGetter> "=" <e:Expression> => ast::AssignmentStatement{source: ast::AssignmentTarget::StructAttr(sg), expression: e},
}

pub Statement: ast::Statement = {
    <r:ReturnStatement> ";" => ast::Statement::Return(r),
    <l:LetStatement> ";" => ast::Statement::Let(l),
    <a:AssignmentStatement> ";" => ast::Statement::Assignment(l),
    <e:Expression> ";" => ast::Statement::Expression(e),
}

pub Block: ast::Block = {
    "{" <v:(Statement ";")*> <e:Expression?> "}" => match e {
        None => ast::Block{statements: s, type_: ast::new_never()},
        Some(e) => {
            let mut v = v;
            v.push(ast::Statement::Expression(e));
            ast::Block{statements: v, type_: ast::TypeUsage::new_unknown(&mut id_generator)}
        }
    }
}

pub TypeUsage: ast::TypeUsage = {
    <n:SpannedIdentifier> => ast::TypeUsage::Named(ast::NamedTypeUsage{name: n}),
    "fn" "(" <args:Comma<TypeUsage>> ")" => ast::TypeUsage::Function(ast::FunctionTypeUsage{arguments: args, return_type: Box::new(ast::TypeUsage::new_unknown(&mut id_generator))}),
    "fn" "(" <args:Comma<TypeUsage>> ")" ":" <rt:TypeUsage> => ast::TypeUsage::Function(ast::FunctionTypeUsage{arguments: args, return_type: Box::new(rt)}),
}

pub VariableDeclaration: ast::VariableDeclaration = {
    <i:SpannedIdentifier> ":" <t:TypeUsage> => ast::VariableDeclaration{name: i, type_usage: t},
}

pub FunctionDeclaration: ast::FunctionDeclaration {
    "fn" <n:SpannedIdentifier> "(" <args:Comma<VariableDeclaration>> ")" => ast::FunctionDeclaration{name: n, arguments: args, return_type: ast::TypeUsage::new_unknown(&mut id_generator)},
    "fn" <n:SpannedIdentifier> "(" <args:Comma<VariableDeclaration>> ")" ":" <rt:TypeUsage> => ast::FunctionDeclaration{name: n, arguments: args, return_type: rt},
}

pub Function: ast::Function = {
    <d:FunctionDeclaration> <b:Block> => ast::Function{declaration: d, block: b}
}

pub StructField: ast::StructField = {
    <i:SpannedIdentifier> ":" <t:TypeUsage> => (i, t),
}

pub StructTypeDeclaration: ast::StructTypeDeclaration {
    "type" <i:SpannedIdentifier> "struct" "{" Comma<StructField> "}"
}

pub TypeAliasDeclaration: ast::TypeAliasDeclaration {
    "type" <i:SpannedIdentifier> "=" <t:TypeUsage> ";" => ast::AliasTypeDeclaration{name: i, replaces: t}
}

pub TypeDeclaration: ast::TypeDeclaration {
    <s:StructTypeDeclaration> => ast::TypeDeclaration::Struct(s),
    <a:AliasTypeDeclaration> => ast::TypeDeclaration::Alias(a),
}

pub Impl: ast::Impl {
    "impl" <i:SpannedIdentifier> "{" <f:Function*> "}" => ast::Impl{struct_name: i, functions: s}
}

pub ModuleItem: ast::ModuleItem {
    <f:Function> => ast::ModuleItem::Function(f),
    <td:TypeDeclaration> => ast::ModuleItem::TypeDeclaration(td),
    <i:Impl> => ast::ModuleItem::Impl(i),
}

pub Module: ast::Module = {
    <i:ModuleItem*> => ast::Module{items: i}
}

// From https://lalrpop.github.io/lalrpop/tutorial/006_macros.html
// Comma seperated list of T with optional trailing comma
Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Spanned<Rule>: ast::Spanned<Rule> = {
  <l: @L> <rule: Rule> <r: @R> => ast::Spanned{span: ast::Span{left: l, right: r}, value: rule}
};
